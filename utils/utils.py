import os
import jwt
import re
import struct
import base64
import subprocess
import requests
import binascii
from roadtools.roadlib.deviceauth import DeviceAuthentication
from roadtools.roadlib.auth import Authentication
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend
from cryptography.x509 import load_pem_x509_certificate
from cryptography import x509
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes


def get_client_name_by_guid(guid: str) -> str:
    guid_to_name = {
        "1b730954-1685-4b74-9bfd-dac224a7b894": "aadps",
        "04b07795-8ddb-461a-bbee-02f9e1bf7b46": "azcli",
        "1fec8e78-bce4-4aaf-ab1b-5451cc387264": "teams",
        "1950a258-227b-4e31-a9cf-717495945fc2": "azps",
        "ecd6b820-32c2-49b6-98a6-444530e5a77a": "edge",
        "29d9ed98-a469-4536-ade2-f981bc1d605e": "broker",
        "9ba1a5c7-f17a-4de9-a1f1-6178c8d51223": "companyportal",
    }
    return guid_to_name.get(guid.lower(), f"unknown ({guid})")


def get_nonce():
    response = requests.post(
        url=f"https://login.microsoftonline.com/645064ee-9b6e-43db-9d46-fe81a65cfdea/oauth2/token",
        data='grant_type=srv_challenge'
    )
    return response.json()['Nonce']


def get_tenantid(domain):
    res = requests.get(f'https://login.microsoftonline.com/{domain}/.well-known/openid-configuration')
    token_endpoint = res.json()['token_endpoint']
    return token_endpoint.split('/')[3]


def get_devicetoken(tenant, certpfx, logger=None):
    if logger:
        logger.info(f"requesting device token for tenant '{tenant}'")
    nonce = get_nonce()
    tid = get_tenantid(tenant)

    certpath = f'device_cert.pem'
    keypath = f'device_key.pem'
    extract_pfx(certpfx, certpath, keypath)

    with open(certpath, "rb") as certf:
        certificate = x509.load_pem_x509_certificate(certf.read())
    with open(keypath, "rb") as keyf:
        keydata = keyf.read()

    os.remove(certpath)
    os.remove(keypath)

    certder = certificate.public_bytes(serialization.Encoding.DER)
    certbytes = base64.b64encode(certder)

    headers = {
        "alg": "RS256",
        "typ": "JWT",
        "x5c": certbytes.decode('utf-8'),
    }
    payload = {
        "resource": "https://enrollment.manage.microsoft.com/",
        "client_id": "29d9ed98-a469-4536-ade2-f981bc1d605e",
        "request_nonce": nonce,
        "win_ver": "10.0.19041.1806",
        "grant_type": "device_token",
        "scope": "sid",
        "redirect_uri": "ms-aadj-redir://auth/mdm",
        "iss": "aad:brokerplugin"
    }

    reqjwt = jwt.encode(payload, algorithm='RS256', key=keydata, headers=headers)

    res = requests.post(
        url=f'https://login.microsoftonline.com/{tid}/oauth2/token',
        data=f'windows_api_version=2.2&grant_type=urn%3aietf%3aparams%3aoauth%3agrant-type%3ajwt-bearer&request={reqjwt}'
    )
    return res.json()['access_token']


def gettokens(username, password, clientid, resource, logger=None):
    if logger:
        logger.info(
            f"performing username/password auth for '{username}' using client_id='{clientid}' and resource='{resource}'"
        )
    auth = Authentication(username, password, None, clientid)
    auth.resource_uri = resource
    return auth.authenticate_username_password()


def deviceauth(username, password, refresh_token, certpfx, proxy, logger=None):
    if logger:
        method = "password" if password else "refresh token"
        logger.info(f"performing DEVICEAUTH for user '{username}' using {method}")
    device_auth = DeviceAuthentication()
    device_auth.proxies = proxy
    device_auth.verify = False
    auth = Authentication()
    auth.proxies = proxy
    auth.verify = False
    device_auth.auth = auth

    device_auth.loadcert(None, None, certpfx, 'password')

    if password:
        response = device_auth.get_prt_with_password(username, password)
    else:
        response = device_auth.get_prt_with_refresh_token(refresh_token)

    return response['refresh_token'], response['session_key']


def prtauth(prt, session_key, client_id, resource, redirect_uri, proxy, logger):
    client_name = get_client_name_by_guid(client_id)
    logger.info(f"Performing PRTAUTH with these parameters: client_id='{client_id}' ({client_name}), resource='{resource}', redirect_uri='{redirect_uri}'")
    device_auth = DeviceAuthentication()
    device_auth.proxies = proxy
    device_auth.verify = False
    auth = Authentication()
    auth.proxies = proxy
    auth.verify = False
    device_auth.auth = auth

    device_auth.prt = prt
    device_auth.session_key = binascii.unhexlify(session_key)
    res = device_auth.aad_brokerplugin_prt_auth(
        client_id=client_id,
        resource=resource,
        redirect_uri=redirect_uri,
    )

    if 'error' in res.keys():
        print(res['error_description'])
        return None

    return res['access_token'], res['refresh_token']


def renew_token(refresh_token, client_id, scope, proxy, logger=None):
    if logger:
        client_name = get_client_name_by_guid(client_id)
        logger.info(
            f"renewing token using client_id='{client_id}' ({client_name}) with scope='{scope}'"
        )
    data = {
        'client_id': client_id,
        'grant_type': 'refresh_token',
        'refresh_token': refresh_token,
        'scope': scope
    }

    response = requests.post(
        "https://login.microsoftonline.com/common/oAuth2/v2.0/token",
        data=data,
        proxies=proxy,
        verify=False
    )
    json = response.json()
    return json['access_token']


def token_renewal_for_enrollment(url, access_token, proxy, logger=None):
    if logger:
        logger.info(f"retrieving enrollment token from '{url}'")
    headers = {'Authorization': 'Bearer {}'.format(access_token)}

    response = requests.get(
        url=f"{url}?api-version=1.0",
        headers=headers,
        proxies=proxy,
        verify=False
    )

    return response.json()['Result']['Token']


def create_pfx(certpath, keypath, pfxpath):
    with open(certpath, 'rb') as public_key_file:
        cert_bytes = public_key_file.read()

    with open(keypath, 'rb') as private_key_file:
        key_bytes = private_key_file.read()

    certificate = load_pem_x509_certificate(cert_bytes, default_backend())
    private_key = serialization.load_pem_private_key(key_bytes, None, default_backend())

    pfx = serialization.pkcs12.serialize_key_and_certificates(
        pfxpath.encode('utf-8'),
        private_key,
        certificate,
        None,
        serialization.BestAvailableEncryption(b'password')
    )

    with open(pfxpath, 'wb') as outfile:
        outfile.write(pfx)

    return


def extract_pfx(pfxpath, certpath, keypath):
    subprocess.run(f'openssl pkcs12 -in {pfxpath} -nodes -password pass:password -out {certpath} -clcerts', shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    subprocess.run(f'openssl pkcs12 -in {pfxpath} -nodes -password pass:password -out {keypath} -nocerts -nodes', shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    return


def get_str_and_next(blob, start):
    str_size = (struct.unpack('<I', blob[start:start + 0x4])[0]) * 2
    str = blob[start + 0xc:start + 0xc + str_size].decode('utf-16le')

    next = start + 0xc + len(str) * 2
    if next % 4 != 0:
        next += +2

    return str, next


def save_encrypted_message_as_smime(encrypted_message, filename):

    smime_header = (
        "MIME-Version: 1.0\n"
        f'Content-Disposition: attachment; filename="{filename}"\n'
        f'Content-Type: application/pkcs7-mime; smime-type=enveloped-data; name="{filename}"\n'
        "Content-Transfer-Encoding: base64\n\n"
    )

    wrapped_string = '\n'.join([encrypted_message[i:i + 64] for i in range(0, len(encrypted_message), 64)])
    smime_message = smime_header + wrapped_string

    with open(filename, "w") as f:
        f.write(smime_message)


def decrypt_smime_file(filename, keypath):
    result = subprocess.run(f'cat {filename} | openssl cms -decrypt -inkey {keypath}', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return result.stdout.decode('utf-8')


def aes_decrypt(key, iv, content):
    cipher = Cipher(algorithms.AES(base64.b64decode(key)), modes.CBC(base64.b64decode(iv)), backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_data = decryptor.update(content) + decryptor.finalize()
    return decrypted_data
